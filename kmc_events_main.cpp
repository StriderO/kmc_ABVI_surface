#include <cstdio>
#include <iostream>
#include <vector>
#include "kmc_global.h"
#include "kmc_events.h"

using namespace std;

double class_events::main(){
	// a probability map will first generated by calculating all possible moves
	// then randomly picked the ACTUAL move based on the probability map

	// defect information
	vector <int>    etype; // type of the event: 0: ITL JUMP; 1: VCC JUMP; 7: F-P GENR; 8: VCC CRTN
	vector <double> rates; // transition rates
	vector <int>    ilist; // IDs in the lists
	vector <int>    nltcp; // ltcp of neighbors
	vector <int>	jatom; // the jumping atom
	
	// perform imaginary jumps and cal rates
	double irates= cal_ratesI(etype, rates, ilist, nltcp, jatom); // WARNING: irates before vrates so the recb map can be generated
	double vrates= cal_ratesV(etype, rates, ilist, nltcp, jatom);
    etype.push_back(7); rates.push_back(rate_genr); // the genr event
	double sum_rates= vrates + irates + crates + rate_genr; // sum of all rates

    // check
    if(nA+nB+nV+nAA+nBB+nAB+nM != nx*ny*nz) error(2, "(jump) numbers of ltc points arent consistent, diff=", 1, nA+nB+nV+nAA+nBB+nAB+nM-nx*ny*nz); // check
    if(2*nAA+nA-nB-2*nBB       != sum_mag)  error(2, "(jump) magnitization isnt conserved", 2, 2*nAA+nA-nB-2*nBB, sum_mag);

    // perform the actual jump
    vector <int> list_inf; // a list of all inf events that have lowest energy einf
	double ran= ran_generator();
	double acc_rate= crates/sum_rates; // accumulated rate
	for(int i=0; i<rates.size(); i ++){
        if(is_inf){
            if(rates[i]<= einf) list_inf.push_back(i); // store events with einf for later use 
        }
        else{
            if(ran < crates/sum_rates){
                double acc_cr= 0;
                for(auto it= cvcc.begin(); it != cvcc.end(); it ++){
                    for(int a=0; a< (it->second).rates.size(); a ++){ // access creation paths of the atom
                        if( (ran >= acc_cr) && (ran < (acc_cr + (it->second).rates[a]/sum_rates) ) ){
                            create_vcc(it->first, (it->second).mltcp[a]); 
                            
                            return 1.0/sum_rates;
                        }
                        
                        acc_cr += (it->second).rates[a]/sum_rates;
                    }
                }
            }

            if( (ran >= acc_rate) && (ran < (acc_rate + rates[i]/sum_rates) ) ){			
		        switch(etype[i]){
                    case 0:  actual_jumpI(ilist[i], nltcp[i], jatom[i]); break;
			        case 1:  actual_jumpV(ilist[i], nltcp[i], jatom[i]); break;
                    case 7:  genr(); N_genr ++; break;
                    default: error(2, "(main) an unknown event type", 1, etype[i]);
                }

	            return 1.0/sum_rates;
		
            }
		
		    acc_rate += rates[i]/sum_rates;
        }
	}

    if(is_inf){
        if(0==list_inf.size()) error(2, "(main) no inf event is collected but is_inf= true");

        int j= list_inf[(int) (ran*list_inf.size())]; // the randomly picked inf event that will be performed
        switch(etype[j]){
            case 0:  actual_jumpI(ilist[j], nltcp[j], jatom[j]); break;
			case 1:  actual_jumpV(ilist[j], nltcp[j], jatom[j]); break;
            default: error(2, "(main) an unknown event type in inf events", 1, etype[j]);
        }
        is_inf= false;
        einf= 0;

        return 0;
    }
    else error(2, "(main) can't find finite event");
}

void class_events::actual_jumpV(int vid, int nltcp, int jatom){ // vcc id, neighbor ltcp and jumping atom
    if(jatom==1) Vja[0] ++; // track # of jumping atoms (see log file) 
	else         Vja[1] ++;
	
    int xv= (int) (list_vcc[vid].ltcp/nz)/ny; // vcc position
	int yv= (int) (list_vcc[vid].ltcp/nz)%ny;
	int zv= (int)  list_vcc[vid].ltcp%nz;
    if(states[xv][yv][zv] != 0 || itlAB[xv][yv][zv]) error(2, "(actual_jumpV) the jumping vcc is not a vcc", 1, xv*ny*nz+yv*nz+zv);

	int x= (int) (nltcp/nz)/ny; // neighbor position
	int y= (int) (nltcp/nz)%ny;
	int z= (int)  nltcp%nz;
    if(states[x][y][z] != 1 && states[x][y][z] != -1) error(2, "(actual_jumpV) the jumping atom is not an atom", 1, x*ny*nz+y*nz+z);

	states[xv][yv][zv]= states[x][y][z];
	
    if(srf[x][y][z]){ // if jump into srf atom, becomes vacuum
        nV --;
        nM ++;

        srf[x][y][z]= false;
        states[x][y][z]= 4;
        
        if     (list_vcc[vid].njump < 0) {}
        else if(list_vcc[vid].njump > 9) njump[9] ++;
        else                             njump[list_vcc[vid].njump] ++;
        
        list_vcc.erase(list_vcc.begin()+vid);
    
        srf_check(nltcp);
    }
    else{
        states[x][y][z]= 0;
    	list_vcc[vid].ltcp= x*ny*nz + y*nz + z;
    	if((x-xv)>nx/2) list_vcc[vid].ix --; if((x-xv)<-nx/2) list_vcc[vid].ix ++;
    	if((y-yv)>ny/2) list_vcc[vid].iy --; if((y-yv)<-ny/2) list_vcc[vid].iy ++;
    	if((z-zv)>nz/2) list_vcc[vid].iz --; if((z-zv)<-nz/2) list_vcc[vid].iz ++;
    
        if(list_vcc[vid].njump != -1) list_vcc[vid].njump ++;
    }
    
    crates += update_ratesC(xv*ny*nz+ yv*nz+ zv);
    crates += update_ratesC(x *ny*nz+ y *nz+ z);
}

void class_events::actual_jumpI(int iid, int nltcp, int jatom){
    int xi= (int) (list_itl[iid].ltcp/nz)/ny; // itl position
	int yi= (int) (list_itl[iid].ltcp/nz)%ny;
	int zi= (int)  list_itl[iid].ltcp%nz;
	if(! (-2==states[xi][yi][zi] || (0==states[xi][yi][zi] && itlAB[xi][yi][zi]) || 2==states[xi][yi][zi]))
        error(2, "(actual_jumpI) the jumping itl is not an itl", 1, xi*ny*nz+yi*nz+zi);

	int x= (int) (nltcp/nz)/ny; // neighbor position
	int y= (int) (nltcp/nz)%ny;
	int z= (int)  nltcp%nz;
	
    if(4==states[x][y][z]){
        if(! is_inf) error(2, "(actual_jumpI) an itl to srf jump isnt instant event");        
        rules_recb(true,  iid, nltcp, jatom);
    }
    else if(0==states[x][y][z]){
        for(int i= 0; i<list_vcc.size(); i ++){ // brutal search for the vcc in the list
    		if(nltcp==list_vcc[i].ltcp){
                if     (list_vcc[i].njump < 0) {}
                else if(list_vcc[i].njump > 9) njump[9] ++;
                else                           njump[list_vcc[i].njump] ++;
                
                rules_recb(false, iid, i, jatom);
                break;
            }
        }
    }
    else{
    	if(jatom==1) Ija[0] ++;
    	else         Ija[1] ++;
	    
        switch(states[xi][yi][zi]){ // update numbers before jump
		    case  2: nAA --; break;
    		case  0: nAB --; itlAB[xi][yi][zi]= false; break;
    		case -2: nBB --; break;
    		default: error(2, "(jump) could not find the Itl type in --", 1, states[xi][yi][zi]);
    	}
    	switch(states[x][y][z]){
    		case  1: nA --;  break;
    		case -1: nB --;  break;
    		default: error(2, "(jump) could not find the Atom type in --", 1, states[x][y][z]);
    	}

	    states[xi][yi][zi] -= jatom; // jumping
	    states[x][y][z]    += jatom;
	
	    switch(states[x][y][z]){ // update numbers after jump
		    case  2: nAA ++; break;
		    case  0: nAB ++; itlAB[x][y][z]= true; break;
		    case -2: nBB ++; break;
		    default: error(2, "(jump) could not find the Itl type in ++", 1, states[x][y][z]);
	    }
	    switch(states[xi][yi][zi]){
		    case  1: nA ++;  break;
		    case -1: nB ++;  break;
		    default: error(2, "(jump) could not find the Atom type in ++", 1, states[xi][yi][zi]);
	    }
	
	    list_itl[iid].ltcp= x*ny*nz + y*nz + z;
//	    list_itl[iid].dir=  nid;
//	    list_itl[iid].head= states[x][y][z] - jatom;
	
	    if((x-xi)>nx/2) list_itl[iid].ix --; if((x-xi)<-nx/2) list_itl[iid].ix ++;
	    if((y-yi)>ny/2) list_itl[iid].iy --; if((y-yi)<-ny/2) list_itl[iid].iy ++;
	    if((z-zi)>nz/2) list_itl[iid].iz --; if((z-zi)<-nz/2) list_itl[iid].iz ++;
    }
    
    crates += update_ratesC(xi*ny*nz+ yi*nz+ zi);
    crates += update_ratesC(x *ny*nz+ y *nz+ z);
}
	
void class_events::create_vcc(int altcp, int mltcp){
	int ja= *(&states[0][0][0]+altcp);
    if(ja != 1 && ja != -1) error(2, "(create_vcc) an ja isnt 1 or -1", 1, ja);

    // initialize the vcc in the list_vcc
	int vid= list_vcc.size();
	list_vcc.push_back(vcc());
	
	list_vcc[vid].ltcp= altcp;
	list_vcc[vid].ix= 0;
	list_vcc[vid].iy= 0;
	list_vcc[vid].iz= 0;
    list_vcc[vid].njump= 0;

	// Update states
	*(&states[0][0][0]+mltcp)= ja;
	*(&states[0][0][0]+altcp)= 0;
       *(&srf[0][0][0]+mltcp)= true;
       *(&srf[0][0][0]+altcp)= false;

    srf_check(mltcp);

    nV ++;
    nM --;

    crates += update_ratesC(altcp);
    crates += update_ratesC(mltcp);
}

// functions in backupfun:
//	int vpos[3];
//	events.vac_jump_random(par_pr_vjump, vpos);
//	events.vac_recb(vpos);
//	events.int_motions();

