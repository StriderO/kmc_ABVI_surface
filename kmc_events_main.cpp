#include <cstdio>
#include <iostream>
#include <vector>
#include "kmc_global.h"
#include "kmc_events.h"

using namespace std;

double class_events::main(){
	// a probability map will first generated by calculating all possible moves
	// then randomly picked the ACTUAL move based on the probability map

	// defect information
	vector <int>    etype; // type of the event: 0: ITL JUMP; 1: VCC JUMP; 7: F-P GENR
	vector <double> rates; // transition rates
	vector <int>    ilist; // IDs in the lists
	vector <int>    nltcp; // ltcp of neighbors
	vector <int>	jatom; // the jumping atom
	
	// perform imaginary jumps and cal rates
	double irates= cal_ratesI(etype, rates, ilist, nltcp, jatom); // WARNING: irates before vrates so the recb map can be generated
	double vrates= cal_ratesV(etype, rates, ilist, nltcp, jatom);
    etype.push_back(7); rates.push_back(rate_genr); // the genr event

	double sum_rates= vrates + irates + rate_genr; // sum of all rates
	double ran= ran_generator();
	double acc_rate= 0; // accumulated rate

    // perform the actual jump
	for(int i=0; i<rates.size(); i ++){
        if( (ran >= acc_rate) && (ran < (acc_rate + rates[i]/sum_rates) ) ){			
		    switch(etype[i]){
                case 0:  actual_jumpI(ilist[i], nltcp[i], jatom[i]); break;
			    case 1:  actual_jumpV(ilist[i], nltcp[i], jatom[i]); break;
                case 7:  genr(); N_genr ++; break;
                default: error(2, "(main) an unknown event type", 1, etype[i]);
            }
		
            break;
        }
		
		acc_rate += rates[i]/sum_rates;
	}
	
	if(nA+nB+nV+nAA+nBB+nAB+nM != nx*ny*nz) error(2, "(jump) numbers of ltc points arent consistent, diff=", 1, nA+nB+nV+nAA+nBB+nAB+nM-nx*ny*nz); // check
	if(2*nAA+nA-nB-2*nBB       != sum_mag)  error(2, "(jump) magnitization isnt conserved", 2, 2*nAA+nA-nB-2*nBB, sum_mag);

	return 1.0/sum_rates;
}

void class_events::actual_jumpV(int vid, int nltcp, int jatom){ // vcc id, neighbor ltcp and jumping atom
    if(jatom==1) Vja[0] ++; // track # of jumping atoms (see log file) 
	else         Vja[1] ++;
	
    int xv= (int) (list_vcc[vid].ltcp/nz)/ny; // vcc position
	int yv= (int) (list_vcc[vid].ltcp/nz)%ny;
	int zv= (int)  list_vcc[vid].ltcp%nz;
    if(states[xv][yv][zv] != 0 || itlAB[xv][yv][zv]) error(2, "(actual_jumpV) the jumping vcc is not a vcc", 1, xv*ny*nz+yv*nz+zv);

	int x= (int) (nltcp/nz)/ny; // neighbor position
	int y= (int) (nltcp/nz)%ny;
	int z= (int)  nltcp%nz;
    if(states[x][y][z] != 1 && states[x][y][z] != -1) error(2, "(actual_jumpV) the jumping atom is not an atom", 1, x*ny*nz+y*nz+z);

	states[xv][yv][zv]= states[x][y][z];
	
    if(srf[x][y][z]){ // if jump into srf atom, becomes vacuum
        nV --;
        nM ++;

        srf[x][y][z]= false;
        states[x][y][z]= 4;
        list_vcc.erase(list_vcc.begin()+vid);
    
        srf_check(nltcp);
    }
    else{
        states[x][y][z]= 0;
    	list_vcc[vid].ltcp= x*ny*nz + y*nz + z;
    	if((x-xv)>nx/2) list_vcc[vid].ix --; if((x-xv)<-nx/2) list_vcc[vid].ix ++;
    	if((y-yv)>ny/2) list_vcc[vid].iy --; if((y-yv)<-ny/2) list_vcc[vid].iy ++;
    	if((z-zv)>nz/2) list_vcc[vid].iz --; if((z-zv)<-nz/2) list_vcc[vid].iz ++;
    }
}

void class_events::actual_jumpI(int iid, int nltcp, int jatom){
    int xi= (int) (list_itl[iid].ltcp/nz)/ny; // itl position
	int yi= (int) (list_itl[iid].ltcp/nz)%ny;
	int zi= (int)  list_itl[iid].ltcp%nz;
	if(! (-2==states[xi][yi][zi] || (0==states[xi][yi][zi] && itlAB[xi][yi][zi]) || 2==states[xi][yi][zi]))
        error(2, "(actual_jumpI) the jumping itl is not an itl", 1, xi*ny*nz+yi*nz+zi);

	int x= (int) (nltcp/nz)/ny; // neighbor position
	int y= (int) (nltcp/nz)%ny;
	int z= (int)  nltcp%nz;
	
    if(4==states[x][y][z])
                rules_recb(true,  iid, nltcp, jatom);
    else if(0==states[x][y][z]){
        for(int i= 0; i<list_vcc.size(); i ++){ // brutal search for the vcc in the list
    		if(nltcp==list_vcc[i].ltcp){
                rules_recb(false, iid, i, jatom);
                break;
            }
        }
    }
    else{
    	if(jatom==1) Ija[0] ++;
    	else         Ija[1] ++;
	    
        switch(states[xi][yi][zi]){ // update numbers before jump
		    case  2: nAA --; break;
    		case  0: nAB --; itlAB[xi][yi][zi]= false; break;
    		case -2: nBB --; break;
    		default: error(2, "(jump) could not find the Itl type in --", 1, states[xi][yi][zi]);
    	}
    	switch(states[x][y][z]){
    		case  1: nA --;  break;
    		case -1: nB --;  break;
    		default: error(2, "(jump) could not find the Atom type in --", 1, states[x][y][z]);
    	}

	    states[xi][yi][zi] -= jatom; // jumping
	    states[x][y][z]    += jatom;
	
	    switch(states[x][y][z]){ // update numbers after jump
		    case  2: nAA ++; break;
		    case  0: nAB ++; itlAB[x][y][z]= true; break;
		    case -2: nBB ++; break;
		    default: error(2, "(jump) could not find the Itl type in ++", 1, states[x][y][z]);
	    }
	    switch(states[xi][yi][zi]){
		    case  1: nA ++;  break;
		    case -1: nB ++;  break;
		    default: error(2, "(jump) could not find the Atom type in ++", 1, states[xi][yi][zi]);
	    }
	
	    list_itl[iid].ltcp= x*ny*nz + y*nz + z;
//	    list_itl[iid].dir=  nid;
//	    list_itl[iid].head= states[x][y][z] - jatom;
	
	    if((x-xi)>nx/2) list_itl[iid].ix --; if((x-xi)<-nx/2) list_itl[iid].ix ++;
	    if((y-yi)>ny/2) list_itl[iid].iy --; if((y-yi)<-ny/2) list_itl[iid].iy ++;
	    if((z-zi)>nz/2) list_itl[iid].iz --; if((z-zi)<-nz/2) list_itl[iid].iz ++;
    }
}
	
// functions in backupfun:
//	int vpos[3];
//	events.vac_jump_random(par_pr_vjump, vpos);
//	events.vac_recb(vpos);
//	events.int_motions();

